\section{\textit{Mm} API}

\subsection{MmPoolCreate}
\label{func:MmPoolCreate}
\begin{pdfunction}
{MmPoolCreate(U32\_t size) }
{ 
Creates a memory pool on the OS heap if the amount of space 
is available. MmPoolCreate will return an invalid ID (0xFFFF) if 
operation failed. }
\pdfunctionargin{(U32_t) size}{ Size to allocate for the pool. }
\pdfunctionreturn{(Id_t) }{Pool ID. }{INVALID_ID}{if the pool was not created. }
\pdfunctionreturn{(Id_t) }{Pool ID. }{Other}{Valid ID if successful }
\end{pdfunction}

\subsection{MmPoolDelete}
\label{func:MmPoolDelete}
\begin{pdfunction}
{MmPoolDelete(Id\_t pool\_id) }
{ 
Formats and deletes the pool. }
\pdfunctionargin{(Id_t) pool_id}{ Pool to delete. }
\end{pdfunction}

\subsection{MmPoolFormat}
\label{func:MmPoolFormat}
\begin{pdfunction}
{MmPoolFormat(Id\_t pool\_id) }
{ 
Formats the pool. All data will be lost. }
\pdfunctionargin{(Id_t) pool_id}{ Pool to format. }
\end{pdfunction}


\subsection{MmPoolFreeSpaceGet}
\label{func:MmPoolFreeSpaceGet}
\begin{pdfunction}
{MmPoolFreeSpaceGet(Id\_t pool\_id) }
{ 
Returns the amount of space (in bytes) available in the pool. }
\pdfunctionargin{(Id_t) pool_id}{ Pool ID. }
\pdfunctionreturn{(U32_t) }{Free pool space. }{}{}
\end{pdfunction}

\subsection{MmOsHeapFreeSpaceGet}
\label{func:MmOsHeapFreeSpaceGet}
\begin{pdfunction}
{MmOsHeapFreeSpaceGet(void) }
{ 
Returns the amount of space (in bytes) available on the 
Heap. }
\pdfunctionreturn{(U32_t) }{Free OS heap space. }{}{}
\end{pdfunction}

\subsection{MmAlloc}
\label{func:MmAlloc}
\begin{pdfunction}
{MmAlloc (Id\_t pool\_id, U32\_t size) }
{ 
Dynamically allocates memory in given pool with specified size. 
memory may be freed or reallocated. 
allocation fails, MmAllocDynamic will return NULL. }
\pdfunctionargin{(Id_t) pool_id}{ ID of the pool where the memory will be allocated. }
\pdfunctionargin{(U32_t) size}{ Size to allocate }
\pdfunctionreturn{(void ) }{pointer to memory. }{NULL}{if allocation failed. }
\pdfunctionreturn{(void ) }{pointer to memory. }{Other}{Valid pointer if successful }
\end{pdfunction}

\subsection{MmReAlloc}
\label{func:MmReAlloc}
\begin{pdfunction}
{MmReAlloc (Id\_t pool\_id, void ptr, U32\_t size) }
{ 
Re-Allocates memory in given 
with specified size. The allocation may be 
by passing a different pool ID. If allocation 
MmReAlloc returns OS\_FAIL. In this case the memory will 
remain allocated in the current pool. }
\pdfunctionargin{(Id_t) cur_pool_id}{ Current pool ID of the to-reallocate memory }
\pdfunctionargin{(Id_t) new_pool_id}{ New pool ID of the to-reallocate memory. }
\pdfunctionargin{(U32_t) new_size}{ Size to allocate }
\pdfunctionreturn{(OsResult_t) }{sys call result }{OS_OK}{if re-allocation was successful. }
\pdfunctionreturn{(OsResult_t) }{sys call result }{OS_FAIL}{if the requested block was too large. }
\pdfunctionreturn{(OsResult_t) }{sys call result }{OS_OUT_OF_BOUNDS}{if the pool ID is not part of the pool memory space. }
\end{pdfunction}

\subsection{MmFree}
\label{func:MmFree}
\begin{pdfunction}
{MmFree (Id\_t pool\_id, void ptr) }
{ 
Frees the specified piece of allocated memory,returning it to 
pool. Freed memory will be set to 0. The pointer to the freed memory 
be implicitly set to NULL. }
\pdfunctionargin{(Id_t) pool_id}{ Pool ID of the allocated memory }
\pdfunctionreturn{(OsResult_t) }{sys call result }{OS_OK}{if freeing was successful. }
\pdfunctionreturn{(OsResult_t) }{sys call result }{OS_NULL_POINTER}{if the memory pointer equals NULL }
\pdfunctionreturn{(OsResult_t) }{sys call result }{OS_OUT_OF_BOUNDS}{if the pool ID is not part of the pool memory space. }
\end{pdfunction}

\subsection{MmAllocSizeGet}
\label{func:MmAllocSizeGet}
\begin{pdfunction}
{MmAllocSizeGet(void ptr) }
{ 
Returns the size of the allocated piece of memory. }
\pdfunctionargin{(void *) ptr}{ Pointer to allocated memory. }
\pdfunctionreturn{(U32_t) }{allocation size. }{0}{if the operation failed. }
\pdfunctionreturn{(U32_t) }{allocation size. }{Other}{Valid allocation size. }
\end{pdfunction}
